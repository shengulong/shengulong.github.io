<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nginx on 道法自然</title>
    <link>/tags/nginx/</link>
    <description>Recent content in nginx on 道法自然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx总结</title>
      <link>/blog/2018/03-01-nginx%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/03-01-nginx%E6%80%BB%E7%BB%93/</guid>
      <description>location 指令 工作中经常用到的一个指令，用来对某个路径的请求做特殊处理。比如同样的链接在PC和Web显示不同的页面。
location修饰符 location block匹配request url中domain name 或者ip/por之后的请求部分，即请求资源的路径。
形式如下：
location optional_modifier location_match { }  如下是optional_modifier的类型：
  ​ optional_modifier ​ 含义   ​  =  ​ 请求的url必须严格匹配被location指定的路径，必须完全相同   ​ none ​  如果没有修饰符，将对url做前缀匹配 ​   ​ ^~  ​ 最佳的非正则表达式前缀匹配    ​ ~  ​ 大小写敏感的正则匹配    ​ ~*  ​ 大小写不敏感的正则匹配    location匹配规则  nginx会查找一个精确匹配。如果匹配到了 = modifier，匹配会立即终止，该location就会被选择处理这个请求。 如果没有精确匹配（= modifier），nginx继续进行前缀匹配，对于给定的url，选择最长的前缀匹配。然后依据下列规则，继续匹配。 如果最长的前缀匹配有（^~ modifier），nginx会立即结束查询，选择该location。如果没有 ^~ modifier，该匹配会被暂时存起来，以便搜索可以继续。 最长的匹配被存起来后，nginx会继续匹配正则表达式。nginx移动到 location list 的顶部，然后试着去匹配正则表达式，第一个被匹配的正则表达式会立即被选择处理请求，结束匹配。 如果没有正则表达式被匹配，则之前存储的最长location被选择用来处理请求。  特别需要理解的：nginx正则匹配结果优先于前缀匹配。但是前缀匹配在先，同时允许通过 ^~ 和 = 来改变这种趋势。</description>
    </item>
    
  </channel>
</rss>