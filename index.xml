<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蜗牛保持乐观才会爬的更远 on 持之以恒</title>
    <link>/</link>
    <description>Recent content in 蜗牛保持乐观才会爬的更远 on 持之以恒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Jul 2019 22:49:58 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Maven插件调试方法</title>
      <link>/blog/2019/07/23/maven%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 23 Jul 2019 22:49:58 +0800</pubDate>
      
      <guid>/blog/2019/07/23/maven%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</guid>
      <description>方法 一般的项目，使用IntelliJ IDEA进入Debug模式，通过断点即可进行调试。
但maven编写的插件就不同了，插件需要打包成Jar并被加载到使用它的项目中，执行项目，调用插件，才可以看的插件的运行效果。 如果我们需要在编写插件源码时调试的话，该如何操作？此时便不能直接点击调试按钮进行调试（因为没有Main类）
下面以idea调试为例说明：
调试端配置:以示例插件hello-maven-plugin为例 主要代码：需要引入如下所示的三个maven插件，maven引入包然后编写入口类继承AbstractMojo，相当于main函数， 使用注解@Mojo定义生命周期和插件执行名称。我们需要实现execute方法，当用户执行maven运行命令后，这个地方的代码会被自动执行。
package sample.plugin; import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecutionException; import org.apache.maven.plugins.annotations.Mojo; /** * Says &amp;quot;Hi&amp;quot; to the user. * */ // When processing the source tree to find mojos, [plugin-tools](http://maven.apache.org/plugin-tools/) // looks for classes with either @Mojo Java 5 annotation or &amp;quot;goal&amp;quot; javadoc annotation. // Any class with this annotation are included in the plugin configuration file. @Mojo( name = &amp;quot;sayhi&amp;quot;) public class MyMojo extends AbstractMojo { public void execute() throws MojoExecutionException { // 可以在此处打断点，这样调用这个插件时，就会停在这个断点处 getLog().</description>
    </item>
    
    <item>
      <title>长连接</title>
      <link>/blog/2019/07/06/%E9%95%BF%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sat, 06 Jul 2019 15:06:23 +0800</pubDate>
      
      <guid>/blog/2019/07/06/%E9%95%BF%E8%BF%9E%E6%8E%A5/</guid>
      <description>-[ ] 服务器断开后，客户端是如何保持长连接的？</description>
    </item>
    
    <item>
      <title>Maven自定义插件实现</title>
      <link>/blog/2019/07/06/maven%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:49:23 +0800</pubDate>
      
      <guid>/blog/2019/07/06/maven%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description> maven开发 maven开发 maven插件开发  插件和生命周期的某个阶段绑定 自定义插件命名为：-maven-plugin；maven--plugin是官方插件的命名，拥有商标权   </description>
    </item>
    
    <item>
      <title>Jenkins分布式实现</title>
      <link>/blog/2019/07/06/jenkins%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:43:00 +0800</pubDate>
      
      <guid>/blog/2019/07/06/jenkins%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description>思路 查看jenkins源代码，把jenkins依赖单机的代码内容，修改为依赖分布式机器的内容； 这样做到应用本身无存储状态，容器化后可以做到随便创建和删除。参阅jenkins&amp;rsquo;s blog
jenkins开发相关知识Extend Jenkins、开发者文档  jenkins本身开发指导说明  java8 mavne&amp;gt;=3.5.3 OpenJDK  jenkins插件开发指导说明  step 1: Preparing for Plugin Development step 2: Create a Plugin step 3: Build and Run the Plugin step 4: Extend the Plugin Plugin tutorial Plugin Cookbook Create a new Plugin with a custom build Step Plugin Structure Making your plugin behave in distributed Jenkins IntelliJ IDEA plugin for Stapler方便在idea里开发jenkins的插件 Exposing data to the remote API Manage global settings and tools installations Debugging native Maven jobs Remote debugging a Java application  快速打包jenkins.</description>
    </item>
    
    <item>
      <title>Gerrit分布式实现</title>
      <link>/blog/2019/07/06/gerrit%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:39:37 +0800</pubDate>
      
      <guid>/blog/2019/07/06/gerrit%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description> 思路 查看gerrit源代码，把gerrit依赖单机的代码内容，修改为依赖分布式机器的内容； 这样做到应用本身无存储状态，容器化后可以做到随便创建和删除。
CodeReview相关工具：https://github.com/GerritCodeReview
gerrit版本变更：https://www.gerritcodereview.com/releases-readme.html
gerrit源码：
https://gerrit.googlesource.com/gerrit/
https://github.com/GerritCodeReview/gerrit
构建工具：google内部使用的 bazel bazel安装：https://docs.bazel.build/versions/master/install-os-x.html#install-on-mac-os-x-homebrew
k8s部署方案 google内部源 https://gerrit.googlesource.com/k8s-gerrit/
对应的github源： https://github.com/GerritCodeReview/k8s-gerrit
插件  metrics-reporter-elasticsearch metrics-reporter-jmx []()  </description>
    </item>
    
    <item>
      <title>Goroutine和进程、线程、协程</title>
      <link>/blog/2019/05/26/goroutine%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 26 May 2019 00:57:43 +0800</pubDate>
      
      <guid>/blog/2019/05/26/goroutine%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程  内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法）  线程  内核进行调度(内核级线程)，有CPU时间片的概念，进行抢占式调度（有多种调度算法）  协程  用户级线程，对内核是透明的，也就是系统并不知道有协程的存在，是完全由用户的程序自己调度的；因为是由用户程序自己控制，那么就很难像抢占式 调度那样做到强制的CPU控制权切换到其他进程/线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到 用户自己调度  goroutine  goroutine就是协程，不同的是，Golang在runtime、系统调用等多方面对goroutine调度进行了封装和处理，当遇到长时间执行或者进行系统调用时， 会主动把当前goroutine的CPU (P) 转让出去，让其他goroutine能被调度并执行，也就是Golang从语言层面支持了协程 go语言帮助用户进行调度 不要通过共享内存通信，相反，通过通信共享内存 内存消耗方面
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。 goroutine: 2KB 线程: 8MB  线程/goroutine 切换(调度)开销方面
线程/goroutine 切换开销方面，goroutine 远比线程小 线程: 涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等。 goroutine: 只有三个寄存器的值修改 - PC/SP/DX   goroutine和线程区别 从调度上看，goroutine的调度开销远远小于线程调度开销。
OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。
Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
从栈空间上，goroutine的栈空间更加动态灵活。
每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
goroutine没有一个特定的标识。
在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。
goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。</description>
    </item>
    
    <item>
      <title>Python中的进程线程协程</title>
      <link>/blog/2019/05/25/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sat, 25 May 2019 23:25:56 +0800</pubDate>
      
      <guid>/blog/2019/05/25/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description> 进程  可以充分利用多核，进程间通信会耗费额外的开销，达不到多线程应有的效率  线程  由于GIL的存在，无法利用多核 适合I/O密集型（IO阻塞期间CPU转去执行其他线程） 不适合CPU密集型/计算密集型；对于计算密集型任务，开启多线程几乎没有意义，甚至可能比顺序执行用时更长 （顺序执行时，cpu集中完成这个线程的任务，再转去下一个，没有切换，也就没有切换的消耗；开多线程又不是并发，白白增加了切换消耗） 进程每次释放GIL锁，所属的线程进行锁竞争、切换线程，会消耗资源 线程切换是由操作系统的调度器进行控制的 抢占式调度顺序具有不确定性，需要注意处理数据同步  协程  是一种用户级的轻量级的线程，拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器和栈存放在指定地方，在切换回来的时候，恢复先前的上下文和栈
  用户需要自己编写调度逻辑，控制任务的切换，那么自然可以控制任务的执行顺序 实现：yield(原生)/gevent/greenlet 比线程消耗更少的资源 对cpu来说，协程就是单线程，cpu不用考虑上下文调度和切换的问题，省去了cpu调度的开销，所有协程在一定程度上要优于线程 协程相当于在单个进程里启动里一个单线程，同时又可以实现多线程的效果 协程本质上是一个线程里面的细分，操作系统层面根本不知道这种区分，只当其是一个线程，程序员自己在应用层面通过yield进行协成间的切换
  GIL GIL，即Global Interpreter Lock全局解释器锁，保证任何时刻仅有一个线程在执行。常见例子有CPython（JPython不使用GIL）与Ruby MRI。 不是所有的Python解释器都有GIL。
为什么要有GIL这个东西，不能去掉呢？这是为了实现GC，避免Java里Full GC(stop the world)引入的。更多内容参考 python 线程，GIL 和 ctypes
每个进程一把锁🔒，进程里的线程，只能有一个线程可以获得这把锁，进行工作，其他线程必须等待
在Python语言的主流实现CPython中，GIL 是一个货真价实的全局线程锁，在解释器解释执行任何Python代码时，都需要先获得这把锁才行， 在遇到I/O操作时会释放这把锁。如果是纯计算的程序，没有I/O操作，解释器会每隔100次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）
同一进程下的多线程共享数据，共享意味着竞争，竞争带来无序，为了数据安全所以需要加锁进行数据保护，GIL本质是一把互斥锁，使并发变为串行， 保证同一时间只有一条线程访问解释器级别的数据，这样就保证了解释器级别的数据安全，同时也带来了一些问题，同一进程只有一条线程执行任务， 无法利用多核优势，解决方案可以根据任务的类型来处理，如果是I/O密集型，则需要开多线程提高效率，如果是计算密集型则需要多进程。
遇到阻塞，普通单线程的做法是就地等待，多线程的做法是转去执行其他线程&amp;ndash;这就是开多线程效率提高的原因。 但如果这种阻塞和放开是我们人为可以预料到的，那么我们可以在阻塞的地方yield返回到另一个可以执行的点，这样也实现了CPU的不浪费，同时还少了线程的切换，效率更高
python锁  python线程
  同步锁（互斥锁）-解决数据安全问题-threading.Lock 递归锁-解决线程死锁-threading.R_Lock Semaphore信号量-threading.Semaphere Event同步事件对象-threading.Event-让两个线程保持同步而不是独立的运行：你给我发个信号，我接到了做一个操作，再给你发一个信号，你接到了一个操作，发下一个信号…… Python中的多线程通信-queue线程队列  </description>
    </item>
    
    <item>
      <title>破解Navicat Premium</title>
      <link>/blog/2019/05/22/%E7%A0%B4%E8%A7%A3navicat-premium/</link>
      <pubDate>Wed, 22 May 2019 21:22:49 +0800</pubDate>
      
      <guid>/blog/2019/05/22/%E7%A0%B4%E8%A7%A3navicat-premium/</guid>
      <description> 方法来自Navicat Keygen,已经fork
 Navicat Premium For Mac 12.1.21 简体中文版 已通过测试
 &amp;#10003; navicat121_premium_cs.dmg &amp;#10008; navicat121_premium_en.dmg  仅对 Navicat Premium 版本 &amp;lt; 12.0.24 的说明：
如果你的Navicat版本小于12.0.24，那么navicat-patcher将会终止并且不会修改目标文件。
你必须使用openssl生成RegPrivateKey.pem和rpk文件：
$ openssl genrsa -out RegPrivateKey.pem 2048 $ openssl rsa -in RegPrivateKey.pem -pubout -out rpk  接着用刚生成的rpk文件替换
/Applications/Navicat Premium.app/Contents/Resources/rpk  生成一份自签名的代码证书，并总是信任该证书；创建证书颁发机构时，名称和电子邮件地址随便写
 下载Navicat Premium中文版：https://www.navicat.com.cn/download/navicat-premium ，破解时，选择Simplified Chinese语言
 关掉自动升级吧，省的再次破解
  参考123
 https://www.zhb127.com/archives/macos-navicat-keygen.html ↩ https://www.zhb127.com/archives/macos-codesign-gdb.html ↩ https://www.jianshu.com/p/54c2a8c62ee5 ↩   </description>
    </item>
    
    <item>
      <title>并发中的各种锁的概念</title>
      <link>/blog/2019/05/18/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 18 May 2019 23:16:13 +0800</pubDate>
      
      <guid>/blog/2019/05/18/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>并发vs并行  并行是指两个或者多个事件在同一时刻发生 并发是指两个或多事件在同一时间段内发生  原子锁 原子锁是指原子操作，原子操作是不会被中断的，常用的原子操作：
InterLockedAdd InterLockedExchange InterLockedCompareExchange InterLockedIncrement InterLockedDecrement InterLockedAnd InterLockedOr  自旋锁：spinlock 非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁； 自选锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu; 用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。
互斥量/互斥锁：mutex 是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。 互斥量的加锁和解锁必须在同一线程内完成，避免死锁。只有一个线程可以使用共享资源。mutex可以说是semaphore在仅取值0/1时的特例
信号量：semaphore 信号允许多个线程同时使用共享资源，但是需要限制在同一时刻访问此资源的最大线程数目；信号量包含互斥量
临界区：critical section 访问共享资源的一段代码；同一时刻，只能有一个线程进入临界区，实现共享资源的访问
资源共享：跨进程vs跨线程 — 临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。 - 使用互斥锁不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享 - 使用信号量和事件机制也可以实现跨进程的线程通信
进程vs线程  进程的内存空间是天然独立的，线程的内存空间是天然共享的。正因为如此，进程通信/线程同步才是系统编程的很大一块内容 进程的执行时间：CPU先加载上下文(程序的执行环境：比如内存存储，比如读写文件就会涉及硬盘I/O，网络通讯就会涉及网络I/O，玩游戏就会涉及显卡资源等)-&amp;gt;CPU执行代码片段-&amp;gt;CPU保存上下文， 以便还没有执行结束程序获得CPU时间片后继续执行。 线程的执行时间：线程由于共享进程资源(各种I/O，内存资源等)，就少了这部分的时间消耗，当然线程之间切换也会消耗少许时间，但相比进程切换消耗的时间，就小很多了。 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位 可以理解为：进程是一个资源的容器，为进程里的所有线程提供共享资源 进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在 进程可以没有线程，但是没有线程的进程就无法获取CPU时间片，所以至少有一个主线程 线程他自身也有栈，寄存器等。这里可以从Java的内存模型去看，线程栈中拥有外部变量的拷贝，线程对这个拷贝进行处理后，再把这个修改后的拷贝刷新回主内存。 进程是资源竞争的基本单位，比如竞争CPU的调度，以及申请内存（物理地址空间） 进程之间相互独立安全性高，如果两个进程之间需要进行（事件通知，数据传输，资源共享，进程控制）那么就需要通过进程间通信（管道，消息队列，共享内存，信号量等）的方式来达成 进程有自己的内存，通过分页将虚拟地址空间映射到物理地址空间来存储数据 线程共享进程的虚拟地址空间（共享段、数据段）、用户ID和组ID、文件描述符表、当前工作目录，但是线程也有自己的一部分数据，例如一组寄存器（用于线程切换上下文）、用户栈（保存私有数据）、线程优先级等 参考http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 及其讨论   以下内容来自知乎：
 作者：胖君 链接：https://www.zhihu.com/question/39850927/answer/242109380 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。   核心矛盾是“竞态条件”，即多个线程同时读写某个字段。 竞态条件下多线程争抢的是“竞态资源”。 涉及读写竟态资源的代码片段叫“临界区”。 保证竟态资源安全的最朴素的一个思路就是让临界区代码“互斥”，即同一时刻最多只能有一个线程进入临界区。 最朴素的互斥手段：在进入临界区之前，用if检查一个bool值，条件不满足就“忙等”。这叫“锁变量”。 但锁变量不是线程安全的。因为“检查-占锁”这个动作不具备“原子性”。 “TSL指令”就是原子性地完成“检查-占锁”的动作。 就算不用TSL指令，也可以设计出线程安全的代码，有一种既巧妙又简洁的结构叫“自旋锁”。当然还有其他更复杂的锁比如“Peterson锁”。 但自旋锁的缺点是条件不满足时会“忙等待”，需要后台调度器重新分配时间片，效率低。 解决忙等待问题的是：“sleep”和“wakeup”两个原语。sleep阻塞当前线程的同时会让出它占用的锁。wakeup可以唤醒在目标锁上睡眠的线程。 使用sleep和wakeup原语，保证同一时刻只有一个线程进入临界区代码片段的锁叫“互斥量”。 把互斥锁推广到&amp;rdquo;N&amp;rdquo;的空间，同时允许有N个线程进入临界区的锁叫“信号量”。 互斥量和信号量的实现都依赖TSL指令保证“检查-占锁”动作的原子性。 把互斥量交给程序员使用太危险，有些编程语言实现了“管程”的特性，从编译器的层面保证了临界区的互斥，比如Java的synchronized关键字。 并没有“同步锁”这个名词，Java的synchronized正确的叫法应该是“互斥锁”，“独占锁”或者“内置锁”。但有的人“顾名思义”叫它同步锁。   几个点稍微展开一下，首先，不是所有变量都可以是竞态资源。以Java为例，表示对象状态的成员字段可以构成竞态资源。 方法内部的局部变量就不是竞态资源，因为局部变量的生命周期仅局限于方法栈，不能横跨多个线程。</description>
    </item>
    
    <item>
      <title>Golang文件锁</title>
      <link>/blog/2019/05/18/golang%E6%96%87%E4%BB%B6%E9%94%81/</link>
      <pubDate>Sat, 18 May 2019 22:54:58 +0800</pubDate>
      
      <guid>/blog/2019/05/18/golang%E6%96%87%E4%BB%B6%E9%94%81/</guid>
      <description>多个goroutine同时操作一同一个文件时，很容易出现数据混乱，因此有必要对文件进行加锁 多进程写
协程：用户控制切换 goroutine：用户控制切换-&amp;gt;语言控制 进程/线程：内核OS控制切换 flock是操作系统级别的锁 使用fopen以&amp;rdquo;a&amp;rdquo;追加模式打开时，多个进程写同一log文件不会发送覆盖写的问题，每次都保证在文件末尾写。但是不保证写入的顺序
 并发与多核利用并不是相同的概念，高并发不一定利用了多核，
python协程就是一个典型，协程使用一种轻线程机制，避开了传统多线程的切换开销，实现惊人的并发管理。 但协程本身是运行在单线程里的，协程并不能直接利用多核，仍然受GIL影响。 因为python GIL的存在，python多线程是无法利用多核的。 多进程模式，python提供了multiprocessing模块， 可以用共享内存模式，这个模块为利用多核的应用提供了便利。</description>
    </item>
    
    <item>
      <title>Zsh启动优化</title>
      <link>/blog/2019/05/14/zsh%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 14 May 2019 21:41:40 +0800</pubDate>
      
      <guid>/blog/2019/05/14/zsh%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</guid>
      <description>主要优化方法  偶尔执行一次的sh脚本，不要每次都执行，需要的时候再执行，举例：
# 下面的配置保证每次打开终端的时候，都可以执行python虚拟环境的workon/mkvirtualenv/rmvirtualenv等命令 # source /usr/local/bin/virtualenvwrapper.sh # source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh # 修改为函数的形式，需要执行python虚拟环境命令的时候再执行这个函数 start_virtualenvwrapper() { source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh }  懒加载。有些命令需要的时候再加载，举例：k8s命令kubectl
# lazy load begin if [ $commands[kubectl] ]; then # Placeholder &#39;kubectl&#39; shell function: # Will only be executed on the first call to &#39;kubectl&#39; kubectl() { # Remove this function, subsequent calls will execute &#39;kubectl&#39; directly unfunction &amp;quot;$0&amp;quot; # Load auto-completion source &amp;lt;(kubectl completion zsh) # Execute &#39;kubectl&#39; binary $0 &amp;quot;$@&amp;quot; } fi # lazy load end  把类似$(brew &amp;ndash;prefix dvm)的命令直接修改为其执行后的路径值，因为这条命令执行比较耗时</description>
    </item>
    
    <item>
      <title>Curl常用操作</title>
      <link>/blog/2019/05/13/curl%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 13 May 2019 11:02:34 +0800</pubDate>
      
      <guid>/blog/2019/05/13/curl%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>curl &amp;ndash;help/&amp;ndash;manual查看完整信息
  使用curl post上传文件，multipart/form-data
 如果不设置filename，默认的filename值就是file的名字，本例的&amp;rdquo;go.sum&amp;rdquo;
 curl -x 127.0.0.1:6060 -F &amp;ldquo;appkey=xxxx&amp;rdquo; -F &amp;ldquo;projectCode=platformtool&amp;rdquo; -F &amp;ldquo;appsecret=xxxx&amp;rdquo; -F &amp;ldquo;file=@go.sum;filename=test&amp;rdquo; http://xxxx.tongdun.me/v1/resource/upload
报文内容： POST /v1/resource/upload HTTP/1.1 Host: xxxx.tongdun.me User-Agent: curl/7.54.0 Accept: */* Content-Length: 15262 Expect: 100-continue Content-Type: multipart/form-data; boundary=------------------------7bba7e03d249b584 Connection: close --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;appkey&amp;quot; xxxx --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;projectCode&amp;quot; platformtool --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;appsecret&amp;quot; xxxx --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;test&amp;quot; Content-Type: application/octet-stream cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw= github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ= github.com/BurntSushi/toml v0.</description>
    </item>
    
    <item>
      <title>Mac常用操作</title>
      <link>/blog/2019/05/13/mac%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 13 May 2019 10:43:39 +0800</pubDate>
      
      <guid>/blog/2019/05/13/mac%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description> 在Finder中显示/隐藏隐藏文件
defaults write com.apple.Finder AppleShowAllFiles YES/NO
killall Finder
 打开多个实例
open -n /Applications/xxx.app
 路由查看
netstat -r
   </description>
    </item>
    
    <item>
      <title>个人所得税2019</title>
      <link>/life/2019/05/11/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E2019/</link>
      <pubDate>Sat, 11 May 2019 00:36:45 +0800</pubDate>
      
      <guid>/life/2019/05/11/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E2019/</guid>
      <description>计算方法  个税精灵 个人所得税  关注两个基数  在岗职工的社会保险缴费基数，新的缴费基数通常在每年的7月调整启用,同时对1-6月预收的社会保险费进行差额补退。
 这两个值直接影响五险一金，关乎个人收入，并且很多公司通过采用较低标准减负。
  1. 社保基数，是根据最低标准还是最高标准？还是中间某个值 2. 住房公积金基数，是否是按照工资总额？  五险一金缴纳比例 社保缴费基数“上下限”，根据上一年浙江省在岗职工年平均工资计算，比如：
+ 月平均工资（保留小数点后两位）为61099元÷12月=5091.58元/月 + 保底工资基数（保留小数点后两位）为5091.58×60%=3054.95 + 封顶工资基数（保留小数点后两位）为5091.58×300%=15274.74   目前市本级（含萧山、余杭、富阳）的企业单位职工五险的缴费费率
   - 个人 企业     养老保险 8% 14%   医疗保险 2% 10.5%   失业保险 0.5% 0.5%   工伤保险 0 0.3%   生育保险 0 1.2%    目前市本级（含萧山、余杭、富阳）有雇工的个体工商户职工五险的缴费费率
   - 个人 企业     养老保险 8% 10%   医疗保险 2% 10.</description>
    </item>
    
    <item>
      <title>Markdown语法及常见用法举例</title>
      <link>/blog/2019/05/10/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B/</link>
      <pubDate>Fri, 10 May 2019 21:18:52 +0800</pubDate>
      
      <guid>/blog/2019/05/10/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B/</guid>
      <description>缩进 标题（Headers）
 Markdown 标题支持两种形式：
 1.1 用1~6个#标记
 在标题开头加上1~6个#，依次代表一级标题、二级标题&amp;hellip;.六级标题
 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ###### 六级标题  一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 1.2 用=和-标记
 在标题底下 加上任意个=代表一级标题，-代表二级标题
 一级标题 ====== 二级标题 ----------  一级标题 二级标题 列表（Lists）
 Markdown 支持有序列表和无序列表。列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等
 2.1 无序列表（Unordered Lists）
 无序列表使用-、+和*作为列表标记
 - Red - Green - Blue * Red * Green * Blue + Red + Green + Blue   Red Green Blue</description>
    </item>
    
    <item>
      <title>关于shell的各种括号的用法</title>
      <link>/blog/2019/05/10/%E5%85%B3%E4%BA%8Eshell%E7%9A%84%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 10 May 2019 20:52:10 +0800</pubDate>
      
      <guid>/blog/2019/05/10/%E5%85%B3%E4%BA%8Eshell%E7%9A%84%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>大部分情况可以通用，建议使用双中括号[[]]，不同的shell表现也不尽相同
 正确的用法 1. 逻辑与：[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; -a &amp;quot;3&amp;quot; = &#39;3&#39; ]、[[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; &amp;amp;&amp;amp; &amp;quot;3&amp;quot; = &#39;3&#39; ]]、[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;3&amp;quot; = &#39;3&#39; ] 2. 逻辑或：[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; -o &amp;quot;3&amp;quot; = &#39;3&#39; ]、[[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; || &amp;quot;3&amp;quot; = &#39;3&#39; ]]、[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; ] || [ &amp;quot;3&amp;quot; = &#39;3&#39; ] 3. []可以替换为test :if [ -e zshrctest ];then;echo &amp;quot;yes&amp;quot;;fi 等价于 if test -e zshrctest;then;echo &amp;quot;yes&amp;quot;;fi 3.</description>
    </item>
    
    <item>
      <title>潜意识学习</title>
      <link>/life/2019/05/03/%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/05/03/%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid>
      <description>愿你在所得少于付出时，不会终日愤愤；愿你在所得超过付出时，不必终日惶恐。
—— 东野圭吾
 这个视频系列可以精读：https://www.youtube.com/channel/UCaKZDEMDdQc8t6GzFj1_TDw</description>
    </item>
    
    <item>
      <title>Kafka中消息分配策略</title>
      <link>/blog/2019/04/24/kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/04/24/kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>非淡泊无以明，非宁静无以致远
 Question 关于kafka中partation和consumer的是如何执行分配的。今早骑自行车的时候突然想起这个问题。它是怎么分配的，我记得我看到好几次相关的介绍文章，现在却想不起来？
sense 很多时候，我们在看完一篇技术文档时，感觉对其中的内容都了解了，其实不然。这也是所谓的被动输入和主动输出的区别所在。相比主动输出而言，被动输入缺少了深层思考的态度。得到一些老师的课里就谈到过主动输出的重要性。
很多概念都已经记不起来了，文章的内容可能也不够准确，但重在思考和想法的过程：
Thinking partaion是数据的存储单位，一个topic至少存在一个partation。consumer使用主动拉数据的方式来消费消息，这就是所有已知概念。那么partation和consumer是如何分配的呢？这里我们假设消息数据总量是一样的。
首先，应该存在一个类似LVS的负载均衡器，因为当consumer增加或者减少时，对应的分配策略也需要做相应的调整。在consumer注册成为消费者时，提交的信息中有consumer Group的概念，这非常好理解，即同一个组的consumer会独立处理一份数据。同时，因为有了Group，我们在管理的时候就会简单很多。当然，所有的讨论都是以一个Group为前提的。
1:1 从最简单的开始考虑，假设现在partation和consumer的数量比例是1:1，那就没有那么多事了，简单明了。
1:2 假设是1:2呢？问题来了，好比现在只有一个数据，但有AB两个线程都要读它，且A和B中有且只有一个能读到。这种情况在计算机中相当普遍，通用的处理方式就是加锁，以保证数据只被其中一个线程处理。但加锁就意味着性能开销，尤其是高并发的场景。
继续按照这个思路来考虑，两个consumer同时向一个partation发起请求，需要一个全局锁来控制每个消息只能返回给请求中的一个。相比较1:1的方式，这样的性能肯定是提高了不少。
2:1 假设是2:1呢？这个也很直观，两份数据，但只有一个消费者，那肯定都需要这一个消费者来处理了，就跟CPU任务调度还有些类似。
如果跟1:2的分配策略比较呢？这里通过将原来的一份数据平均分成两份，去掉了1:2中加锁的开销，但只有一个connsumer来消费数据。好比是单核CPU任意处理数据跟双核CPU加锁处理数据。
2:2 假设是2:2呢，我们可以平均分配partation和consumer，而且这样系统性能却得到最大提升，不仅去掉了锁的开销，还有两个线程来同时消费。
结论 通过上面的对比，我们可以清楚的发现，通过调整partation和consumer的数量就可以将系统性能达到最大，完全不需要引入锁机制。这样想的话，分配就很简单了。</description>
    </item>
    
    <item>
      <title>平常心</title>
      <link>/life/2019/03/12/%E5%B9%B3%E5%B8%B8%E5%BF%83/</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/03/12/%E5%B9%B3%E5%B8%B8%E5%BF%83/</guid>
      <description>愿你在所得少于付出时，不会终日愤愤；愿你在所得超过付出时，不必终日惶恐。
—— 东野圭吾
 一切都很准时  New York is 3 hours ahead of California
But it does not make California slow
Someone graduated at the age of 22
but waited 5 years before securing a good job
Someone become a CEO at 25
and died at 50
while another become a CEO at 50
and lived to 90 years
Someone is still single
while someone else got married</description>
    </item>
    
    <item>
      <title>读书有感</title>
      <link>/life/2019/03/03/%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/03/03/%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/</guid>
      <description>19年开始读一些文学书，内心多了30的焦虑，希望从别人的故事中汲取力量。
 创业，从一个小目标开始 创办了zendesk的企业家写的一本回忆录，从透支信用卡、挤经济舱到开全球限量版轿车、坐私人飞机，其中的艰辛只有他自己最清楚。作为一个看客，最触动我的便是：他们年过30，随便去任何一家公司都能领到不错的薪水，但还是毅然决然地选择了自己创业，他们的理由很简单，如果这次创业机会不能好好把握，自己的人生便是死局。
创业，可能是每个有梦想的人都必须走的一条路吧。</description>
    </item>
    
    <item>
      <title>How to use godog</title>
      <link>/blog/2018/12/29/how-to-use-godog/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12/29/how-to-use-godog/</guid>
      <description>首先访问Git的地址：Godog，它也是用来做Go Test一样的事情，只是换了一种形式。引入了一个概念：BDD。通俗的讲，就是虚拟现实场景，完成一个业务的测试。
Godog了解 首先介绍Godog是用来干什么的，我也是根据版本库提供的README来解释的，建议大家自己去看看。首先，我们要定义一个场景：feature。这里我们创建一个文件夹feature，专门用来存储这类文件。然后创建一个文件：godogs.feature。文件内容如下：
# file: $GOPATH/src/godogs/features/godogs.feature Feature: 购买红酒 这里是一堆对这个Feature的描述 描述的继续... Scenario: 买一瓶红酒 Given Neojos Has 5 coins When I buy Red wine Then should be 1 remaining  在控制台执行godog时，控制台会输出默认建议的代码。输出如下：
You can implement step definitions for undefined steps with these snippets: func neojosHasCoins(arg1 int) error { return godog.ErrPending } func iBuyRedWine() error { return godog.ErrPending } func shouldBeRemaining(arg1 int) error { return godog.ErrPending } func FeatureContext(s *godog.Suite) { s.Step(`^Neojos Has (\d+) coins$`, neojosHasCoins) s.</description>
    </item>
    
    <item>
      <title>Net Transport</title>
      <link>/blog/2018/12/08/net-transport/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12/08/net-transport/</guid>
      <description>版本 0.02
在调用第三方请求时，正确使用Client也不是一件非常容易的事。
下面是截取的一段描述，建议Client或Transport在整个服务期间最好是全局单例的，Transport本身会维护连接的状态，而且线程安全。强烈建议，不要使用系统提供的任何默认值。
 The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
 Transport 如下是官方的简要描述。Transport字段在Client中被声明为接口类型，而实现这个接口的是Transport类型（略显绕）。在net包内部也提供了默认的实现变量：DefaultTransport。
// Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper  看一下RoundTripper这个接口，官方描述：
 RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>网站是使用hugo + GitHub搭建的静态网页。在这之前，一直用的是cnblogs，自从无意间看到了https://neojos.com/about/, 其实来源是blog,参考github,github。 不得不说，自己被博主的优秀以及博客的简单明了折服的一塌糊涂。
简单了解hugo之后，发现它更简单、更方便，所以将自己的博客也做了迁移。
直接git clone git@github.com:GitHubSi/blog.git,然后简单修改里面的内容，删除掉作者的博客，添加自己的博客
使用介绍：  Hugo快速入手 博客模版 theme:hugo-ivy 主题hugo-ivy借鉴ivy：Ivy is a static website generator built in Python. It&#39;s small, elegant, and easy to use. hugo 编译 hugo server 本地启动服务 hugo new blog/2019/xxx.md 创建一篇新博客，目录位于content/blog/2019 sh simple-deploy.sh 发布博客到xxx.github.io  评论系统 如果需要，可以考虑isso，因为涉及交互，就不再是静态网站了，需要存储系统，就需要放存储系统的服务器。暂时不考虑。 评论系统效果参考
优化方向  里面内嵌了很多js，需要删除无用的，把有用的js链接本地化，减少网络依赖  注意事项：  修改hugo new xx.md的模版
 位于archetypes/default.md,参考.Format
 --- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .</description>
    </item>
    
    <item>
      <title>SGL&#39;s reference resource</title>
      <link>/resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/resource/</guid>
      <description> 人总是需要不断的学习，完成自我成长，或读一本好书，或读一篇博文，或聆听牛人垂询，或参加一场讨论， 或聆听宣讲
blog  https://neojos.com/ https://yihui.name/cn/  java go python </description>
    </item>
    
  </channel>
</rss>