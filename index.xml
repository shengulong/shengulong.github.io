<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蜗牛保持乐观才会爬的更远 on 道法自然</title>
    <link>/</link>
    <description>Recent content in 蜗牛保持乐观才会爬的更远 on 道法自然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>潜意识学习</title>
      <link>/life/2019/19-05-04-%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/19-05-04-%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid>
      <description>愿你在所得少于付出时，不会终日愤愤；愿你在所得超过付出时，不必终日惶恐。
—— 东野圭吾
 这个视频系列可以精读：https://www.youtube.com/channel/UCaKZDEMDdQc8t6GzFj1_TDw</description>
    </item>
    
    <item>
      <title>mongo EOF</title>
      <link>/blog/2019/2019-04-27-mongo-eof/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-04-27-mongo-eof/</guid>
      <description>很多事情仅仅的是严肃的提出问题都感觉很难，更何况还得要先发现它。
 Question 描述 项目中使用：github.com/globalsign/mgo这个库，在一次主从切换之后，mongo后续的操作都失败了, 错误信息输出：EOF。
引用网上遇到同样问题的其他描述：
 The problem I have is, when the connection to the mongodb server fails (the server drops the connection sometimes or mongodb server fails), then my pointer to the session variable doesn&#39;t work anymore. Even if the internet connection comes back, mgo driver doesn&#39;t reconnect anymore, instead of this I get the error (when I do Find().One() method call): &amp;quot;EOF&amp;quot;
 解决思路   Call Refresh on the session, which makes it discard (or put back in the pool, if the connection is good) the connection it&amp;rsquo;s holding, and pick a new one when necessary.</description>
    </item>
    
    <item>
      <title>Kafka中消息分配策略</title>
      <link>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>非淡泊无以明，非宁静无以致远
 Question 关于kafka中partation和consumer的是如何执行分配的。今早骑自行车的时候突然想起这个问题。它是怎么分配的，我记得我看到好几次相关的介绍文章，现在却想不起来？
sense 很多时候，我们在看完一篇技术文档时，感觉对其中的内容都了解了，其实不然。这也是所谓的被动输入和主动输出的区别所在。相比主动输出而言，被动输入缺少了深层思考的态度。得到一些老师的课里就谈到过主动输出的重要性。
很多概念都已经记不起来了，文章的内容可能也不够准确，但重在思考和想法的过程：
Thinking partaion是数据的存储单位，一个topic至少存在一个partation。consumer使用主动拉数据的方式来消费消息，这就是所有已知概念。那么partation和consumer是如何分配的呢？这里我们假设消息数据总量是一样的。
首先，应该存在一个类似LVS的负载均衡器，因为当consumer增加或者减少时，对应的分配策略也需要做相应的调整。在consumer注册成为消费者时，提交的信息中有consumer Group的概念，这非常好理解，即同一个组的consumer会独立处理一份数据。同时，因为有了Group，我们在管理的时候就会简单很多。当然，所有的讨论都是以一个Group为前提的。
1:1 从最简单的开始考虑，假设现在partation和consumer的数量比例是1:1，那就没有那么多事了，简单明了。
1:2 假设是1:2呢？问题来了，好比现在只有一个数据，但有AB两个线程都要读它，且A和B中有且只有一个能读到。这种情况在计算机中相当普遍，通用的处理方式就是加锁，以保证数据只被其中一个线程处理。但加锁就意味着性能开销，尤其是高并发的场景。
继续按照这个思路来考虑，两个consumer同时向一个partation发起请求，需要一个全局锁来控制每个消息只能返回给请求中的一个。相比较1:1的方式，这样的性能肯定是提高了不少。
2:1 假设是2:1呢？这个也很直观，两份数据，但只有一个消费者，那肯定都需要这一个消费者来处理了，就跟CPU任务调度还有些类似。
如果跟1:2的分配策略比较呢？这里通过将原来的一份数据平均分成两份，去掉了1:2中加锁的开销，但只有一个connsumer来消费数据。好比是单核CPU任意处理数据跟双核CPU加锁处理数据。
2:2 假设是2:2呢，我们可以平均分配partation和consumer，而且这样系统性能却得到最大提升，不仅去掉了锁的开销，还有两个线程来同时消费。
结论 通过上面的对比，我们可以清楚的发现，通过调整partation和consumer的数量就可以将系统性能达到最大，完全不需要引入锁机制。这样想的话，分配就很简单了。</description>
    </item>
    
    <item>
      <title>平常心</title>
      <link>/life/2019/19-03-12-%E5%B9%B3%E5%B8%B8%E5%BF%83/</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/19-03-12-%E5%B9%B3%E5%B8%B8%E5%BF%83/</guid>
      <description>愿你在所得少于付出时，不会终日愤愤；愿你在所得超过付出时，不必终日惶恐。
—— 东野圭吾
 一切都很准时  New York is 3 hours ahead of California
But it does not make California slow
Someone graduated at the age of 22
but waited 5 years before securing a good job
Someone become a CEO at 25
and died at 50
while another become a CEO at 50
and lived to 90 years
Someone is still single
while someone else got married</description>
    </item>
    
    <item>
      <title>读书有感</title>
      <link>/life/2019/19-03-03-%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/19-03-03-%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/</guid>
      <description>19年开始读一些文学书，内心多了30的焦虑，希望从别人的故事中汲取力量。
 创业，从一个小目标开始 创办了zendesk的企业家写的一本回忆录，从透支信用卡、挤经济舱到开全球限量版轿车、坐私人飞机，其中的艰辛只有他自己最清楚。作为一个看客，最触动我的便是：他们年过30，随便去任何一家公司都能领到不错的薪水，但还是毅然决然地选择了自己创业，他们的理由很简单，如果这次创业机会不能好好把握，自己的人生便是死局。
创业，可能是每个有梦想的人都必须走的一条路吧。</description>
    </item>
    
    <item>
      <title>How to use godog</title>
      <link>/blog/2018/12-29-how-to-use-godog/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12-29-how-to-use-godog/</guid>
      <description>首先访问Git的地址：Godog，它也是用来做Go Test一样的事情，只是换了一种形式。引入了一个概念：BDD。通俗的讲，就是虚拟现实场景，完成一个业务的测试。
Godog了解 首先介绍Godog是用来干什么的，我也是根据版本库提供的README来解释的，建议大家自己去看看。首先，我们要定义一个场景：feature。这里我们创建一个文件夹feature，专门用来存储这类文件。然后创建一个文件：godogs.feature。文件内容如下：
# file: $GOPATH/src/godogs/features/godogs.feature Feature: 购买红酒 这里是一堆对这个Feature的描述 描述的继续... Scenario: 买一瓶红酒 Given Neojos Has 5 coins When I buy Red wine Then should be 1 remaining  在控制台执行godog时，控制台会输出默认建议的代码。输出如下：
You can implement step definitions for undefined steps with these snippets: func neojosHasCoins(arg1 int) error { return godog.ErrPending } func iBuyRedWine() error { return godog.ErrPending } func shouldBeRemaining(arg1 int) error { return godog.ErrPending } func FeatureContext(s *godog.Suite) { s.Step(`^Neojos Has (\d+) coins$`, neojosHasCoins) s.</description>
    </item>
    
    <item>
      <title>Net Transport</title>
      <link>/blog/2018/12-08-net-transport/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12-08-net-transport/</guid>
      <description>版本 0.02
在调用第三方请求时，正确使用Client也不是一件非常容易的事。
下面是截取的一段描述，建议Client或Transport在整个服务期间最好是全局单例的，Transport本身会维护连接的状态，而且线程安全。强烈建议，不要使用系统提供的任何默认值。
 The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
 Transport 如下是官方的简要描述。Transport字段在Client中被声明为接口类型，而实现这个接口的是Transport类型（略显绕）。在net包内部也提供了默认的实现变量：DefaultTransport。
// Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper  看一下RoundTripper这个接口，官方描述：
 RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description> 网站是使用hugo + GitHub搭建的静态网页。在这之前，一直用的是cnblogs，自从无意间看到了https://neojos.com/about/。不得不说，自己被博主的优秀以及博客的简单明了折服的一塌糊涂。
简单了解hugo之后，发现它更简单、更方便，所以将自己的博客也做了迁移。
直接git clone git@github.com:GitHubSi/blog.git,然后简单修改里面的内容，删除掉作者的博客，添加自己的博客
使用介绍：  Hugo快速入手 博客模版 theme:hugo-ivy 主题hugo-ivy借鉴ivy：Ivy is a static website generator built in Python. It&#39;s small, elegant, and easy to use. hugo 编译 hugo server 本地启动服务  注意事项(和网站相比存在问题)：  date是当天,则无法展示博客  </description>
    </item>
    
    <item>
      <title>SGL&#39;s reference resource</title>
      <link>/resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/resource/</guid>
      <description> 人总是需要不断的学习，完成自我成长，或读一本好书，或读一篇博文，或聆听牛人垂询，或参加一场讨论， 或聆听宣讲
blog  https://neojos.com/ https://yihui.name/cn/  java go python </description>
    </item>
    
  </channel>
</rss>