<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2019-07 on 持之以恒</title>
    <link>/categories/2019-07/</link>
    <description>Recent content in 2019-07 on 持之以恒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Jul 2019 10:16:20 +0800</lastBuildDate>
    
	<atom:link href="/categories/2019-07/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python的caller对callee模块内部参数的修改生效情况</title>
      <link>/blog/2019/07/24/python%E7%9A%84caller%E5%AF%B9callee%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E5%8F%82%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9%E7%94%9F%E6%95%88%E6%83%85%E5%86%B5/</link>
      <pubDate>Wed, 24 Jul 2019 10:16:20 +0800</pubDate>
      
      <guid>/blog/2019/07/24/python%E7%9A%84caller%E5%AF%B9callee%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E5%8F%82%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9%E7%94%9F%E6%95%88%E6%83%85%E5%86%B5/</guid>
      <description>被调用方callee代码 callee.py #!/usr/bin/env python # -*- coding: utf-8 -*- &amp;quot;&amp;quot;&amp;quot; @Author : xxx@xxx.net @Date : 2019-06-28 @Description : @File : callee.py &amp;quot;&amp;quot;&amp;quot; NAME = &#39;我是模块内部的初始值&#39; print(NAME) print(&#39;模块会在被引入时(import callee)执行一遍,引入本模块会显示此信息&#39;) def fun1(): print(&amp;quot;模块会在被引入时执行一遍，但是不会执行这个函数，除非被调用&amp;quot;) class ClassTemplate(object): # 此处的name变量除非被初始化时显示参数传入，否则使用的是模块内部的全局变量值 def __init__(self, name=NAME): # __name 是私有变量，只有类本身可以访问，子类也不可以访问 # _name 是受保护变量，类本身和子类可以访问，from module import *无法导入 # decorator装饰器/迭代器__iter__、__next__/yield生成器/ self.__name = name print(name) # 如果外面模块修改了这个变量，则显示修改后的变量值 print(NAME) def run(self): print(&amp;quot;my name is %s&amp;quot; % self.__name) @classmethod # 此处的变量value除非被初始化时显示参数传入，否则使用的是模块内部的全局变量值 def class_method(cls, value=NAME): print(value) # 如果外面模块修改了这个变量，则显示修改后的变量值 print(NAME) # cls.</description>
    </item>
    
    <item>
      <title>Maven插件调试方法</title>
      <link>/blog/2019/07/23/maven%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 23 Jul 2019 22:49:58 +0800</pubDate>
      
      <guid>/blog/2019/07/23/maven%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</guid>
      <description>方法 一般的项目，使用IntelliJ IDEA进入Debug模式，通过断点即可进行调试。
但maven编写的插件就不同了，插件需要打包成Jar并被加载到使用它的项目中，执行项目，调用插件，才可以看的插件的运行效果。 如果我们需要在编写插件源码时调试的话，该如何操作？此时便不能直接点击调试按钮进行调试（因为没有Main类）
下面以idea调试为例说明：
调试端配置:以示例插件hello-maven-plugin为例 主要代码：需要引入如下所示的三个maven插件，maven引入包然后编写入口类继承AbstractMojo，相当于main函数， 使用注解@Mojo定义生命周期和插件执行名称。我们需要实现execute方法，当用户执行maven运行命令后，这个地方的代码会被自动执行。
package sample.plugin; import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecutionException; import org.apache.maven.plugins.annotations.Mojo; /** * Says &amp;quot;Hi&amp;quot; to the user. * */ // When processing the source tree to find mojos, [plugin-tools](http://maven.apache.org/plugin-tools/) // looks for classes with either @Mojo Java 5 annotation or &amp;quot;goal&amp;quot; javadoc annotation. // Any class with this annotation are included in the plugin configuration file. @Mojo( name = &amp;quot;sayhi&amp;quot;) public class MyMojo extends AbstractMojo { public void execute() throws MojoExecutionException { // 可以在此处打断点，这样调用这个插件时，就会停在这个断点处 getLog().</description>
    </item>
    
    <item>
      <title>长连接</title>
      <link>/blog/2019/07/06/%E9%95%BF%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sat, 06 Jul 2019 15:06:23 +0800</pubDate>
      
      <guid>/blog/2019/07/06/%E9%95%BF%E8%BF%9E%E6%8E%A5/</guid>
      <description>-[ ] 服务器断开后，客户端是如何保持长连接的？</description>
    </item>
    
    <item>
      <title>Maven自定义插件实现</title>
      <link>/blog/2019/07/06/maven%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:49:23 +0800</pubDate>
      
      <guid>/blog/2019/07/06/maven%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>maven开发 maven开发 maven插件开发  插件和生命周期的某个阶段绑定 自定义插件命名为：-maven-plugin；maven--plugin是官方插件的命名，拥有商标权   插件分类  build插件：会在build阶段被执行，应该配置在POM的元素中 reporting插件：生成站点的时候会执行，应该配置在POM的元素中。因为reporting插件的结果是生成的站点的一部分， 所以这种插件应该是国际化和本地化的  插件配置 Maven插件都是通过指定一个元素来配置的。而该元素中的子元素，都是Mojo中的property。 详见Guide to Configuring Plug-ins</description>
    </item>
    
    <item>
      <title>Jenkins分布式实现</title>
      <link>/blog/2019/07/06/jenkins%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:43:00 +0800</pubDate>
      
      <guid>/blog/2019/07/06/jenkins%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description>思路 查看jenkins源代码，把jenkins依赖单机的代码内容，修改为依赖分布式机器的内容； 这样做到应用本身无存储状态，容器化后可以做到随便创建和删除。参阅jenkins&amp;rsquo;s blog
jenkins开发相关知识Extend Jenkins、开发者文档  jenkins本身开发指导说明  java8 mavne&amp;gt;=3.5.3 OpenJDK  jenkins插件开发指导说明  step 1: Preparing for Plugin Development step 2: Create a Plugin step 3: Build and Run the Plugin step 4: Extend the Plugin Plugin tutorial Plugin Cookbook Create a new Plugin with a custom build Step Plugin Structure Making your plugin behave in distributed Jenkins IntelliJ IDEA plugin for Stapler方便在idea里开发jenkins的插件 Exposing data to the remote API Manage global settings and tools installations Debugging native Maven jobs Remote debugging a Java application  快速打包jenkins.</description>
    </item>
    
    <item>
      <title>Gerrit分布式实现</title>
      <link>/blog/2019/07/06/gerrit%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 06 Jul 2019 07:39:37 +0800</pubDate>
      
      <guid>/blog/2019/07/06/gerrit%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description> 思路 查看gerrit源代码，把gerrit依赖单机的代码内容，修改为依赖分布式机器的内容； 这样做到应用本身无存储状态，容器化后可以做到随便创建和删除。
CodeReview相关工具：https://github.com/GerritCodeReview
gerrit版本变更：https://www.gerritcodereview.com/releases-readme.html
gerrit源码：
https://gerrit.googlesource.com/gerrit/
https://github.com/GerritCodeReview/gerrit
构建工具：google内部使用的 bazel bazel安装：https://docs.bazel.build/versions/master/install-os-x.html#install-on-mac-os-x-homebrew bazel介绍：https://www.cnblogs.com/Leo_wl/p/4458115.html
k8s部署方案 google内部源 https://gerrit.googlesource.com/k8s-gerrit/
对应的github源： https://github.com/GerritCodeReview/k8s-gerrit
插件  metrics-reporter-elasticsearch metrics-reporter-jmx []()  </description>
    </item>
    
  </channel>
</rss>