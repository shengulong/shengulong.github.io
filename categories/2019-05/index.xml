<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2019-05 on 持之以恒</title>
    <link>/categories/2019-05/</link>
    <description>Recent content in 2019-05 on 持之以恒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 May 2019 21:22:49 +0800</lastBuildDate>
    
	<atom:link href="/categories/2019-05/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>破解Navicat Premium</title>
      <link>/blog/2019/05/22/%E7%A0%B4%E8%A7%A3navicat-premium/</link>
      <pubDate>Wed, 22 May 2019 21:22:49 +0800</pubDate>
      
      <guid>/blog/2019/05/22/%E7%A0%B4%E8%A7%A3navicat-premium/</guid>
      <description> 方法来自Navicat Keygen,已经fork
 Navicat Premium For Mac 12.1.21 简体中文版 已通过测试
 仅对 Navicat Premium 版本 &amp;lt; 12.0.24 的说明：
如果你的Navicat版本小于12.0.24，那么navicat-patcher将会终止并且不会修改目标文件。
你必须使用openssl生成RegPrivateKey.pem和rpk文件：
$ openssl genrsa -out RegPrivateKey.pem 2048 $ openssl rsa -in RegPrivateKey.pem -pubout -out rpk  接着用刚生成的rpk文件替换
/Applications/Navicat Premium.app/Contents/Resources/rpk  生成一份自签名的代码证书，并总是信任该证书；创建证书颁发机构时，名称和电子邮件地址随便写
 下载Navicat Premium中文版：https://www.navicat.com.cn/download/navicat-premium ，破解时，选择Simplified Chinese语言
 关掉自动升级吧，省的再次破解
  参考123
 https://www.zhb127.com/archives/macos-navicat-keygen.html ↩ https://www.zhb127.com/archives/macos-codesign-gdb.html ↩ https://www.jianshu.com/p/54c2a8c62ee5 ↩   </description>
    </item>
    
    <item>
      <title>并发中的各种锁的概念</title>
      <link>/blog/2019/05/18/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 18 May 2019 23:16:13 +0800</pubDate>
      
      <guid>/blog/2019/05/18/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>原子锁 原子锁是指原子操作，原子操作是不会被中断的，常用的原子操作：
InterLockedAdd InterLockedExchange InterLockedCompareExchange InterLockedIncrement InterLockedDecrement InterLockedAnd InterLockedOr  自旋锁：spinlock 非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁； 自选锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu; 用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。
互斥量/互斥锁：mutex 是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。 互斥量的加锁和解锁必须在同一线程内完成，避免死锁。只有一个线程可以使用共享资源。mutex可以说是semaphore在仅取值0/1时的特例
信号量：semaphore 信号允许多个线程同时使用共享资源，但是需要限制在同一时刻访问此资源的最大线程数目；信号量包含互斥量
临界区：critical section 访问共享资源的一段代码；同一时刻，只能有一个线程进入临界区，实现共享资源的访问
资源共享：跨进程vs跨线程 — 临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。 - 使用互斥锁不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享 - 使用信号量和事件机制也可以实现跨进程的线程通信
进程vs线程  进程的内存空间是天然独立的，线程的内存空间是天然共享的。正因为如此，进程通信/线程同步才是系统编程的很大一块内容 进程的执行时间：CPU先加载上下文(程序的执行环境：比如内存存储，比如读写文件就会涉及硬盘I/O，网络通讯就会涉及网络I/O，玩游戏就会涉及显卡资源等)-&amp;gt;CPU执行代码片段-&amp;gt;CPU保存上下文， 以便还没有执行结束程序获得CPU时间片后继续执行。 线程的执行时间：线程由于共享进程资源(各种I/O，内存资源等)，就少了这部分的时间消耗，当然线程之间切换也会消耗少许时间，但相比进程切换消耗的时间，就小很多了。 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位 可以理解为：进程是一个资源的容器，为进程里的所有线程提供共享资源 进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在 进程可以没有线程，但是没有线程的进程就无法获取CPU时间片，所以至少有一个主线程 线程他自身也有栈，寄存器等。这里可以从Java的内存模型去看，线程栈中拥有外部变量的拷贝，线程对这个拷贝进行处理后，再把这个修改后的拷贝刷新回主内存。 进程是资源竞争的基本单位，比如竞争CPU的调度，以及申请内存（物理地址空间） 进程之间相互独立安全性高，如果两个进程之间需要进行（事件通知，数据传输，资源共享，进程控制）那么就需要通过进程间通信（管道，消息队列，共享内存，信号量等）的方式来达成 进程有自己的内存，通过分页将虚拟地址空间映射到物理地址空间来存储数据 线程共享进程的虚拟地址空间（共享段、数据段）、用户ID和组ID、文件描述符表、当前工作目录，但是线程也有自己的一部分数据，例如一组寄存器（用于线程切换上下文）、用户栈（保存私有数据）、线程优先级等 参考http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 及其讨论   以下内容来自知乎：
 作者：胖君 链接：https://www.zhihu.com/question/39850927/answer/242109380 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。   核心矛盾是“竞态条件”，即多个线程同时读写某个字段。 竞态条件下多线程争抢的是“竞态资源”。 涉及读写竟态资源的代码片段叫“临界区”。 保证竟态资源安全的最朴素的一个思路就是让临界区代码“互斥”，即同一时刻最多只能有一个线程进入临界区。 最朴素的互斥手段：在进入临界区之前，用if检查一个bool值，条件不满足就“忙等”。这叫“锁变量”。 但锁变量不是线程安全的。因为“检查-占锁”这个动作不具备“原子性”。 “TSL指令”就是原子性地完成“检查-占锁”的动作。 就算不用TSL指令，也可以设计出线程安全的代码，有一种既巧妙又简洁的结构叫“自旋锁”。当然还有其他更复杂的锁比如“Peterson锁”。 但自旋锁的缺点是条件不满足时会“忙等待”，需要后台调度器重新分配时间片，效率低。 解决忙等待问题的是：“sleep”和“wakeup”两个原语。sleep阻塞当前线程的同时会让出它占用的锁。wakeup可以唤醒在目标锁上睡眠的线程。 使用sleep和wakeup原语，保证同一时刻只有一个线程进入临界区代码片段的锁叫“互斥量”。 把互斥锁推广到&amp;rdquo;N&amp;rdquo;的空间，同时允许有N个线程进入临界区的锁叫“信号量”。 互斥量和信号量的实现都依赖TSL指令保证“检查-占锁”动作的原子性。 把互斥量交给程序员使用太危险，有些编程语言实现了“管程”的特性，从编译器的层面保证了临界区的互斥，比如Java的synchronized关键字。 并没有“同步锁”这个名词，Java的synchronized正确的叫法应该是“互斥锁”，“独占锁”或者“内置锁”。但有的人“顾名思义”叫它同步锁。   几个点稍微展开一下，首先，不是所有变量都可以是竞态资源。以Java为例，表示对象状态的成员字段可以构成竞态资源。 方法内部的局部变量就不是竞态资源，因为局部变量的生命周期仅局限于方法栈，不能横跨多个线程。</description>
    </item>
    
    <item>
      <title>Golang文件锁</title>
      <link>/blog/2019/05/18/golang%E6%96%87%E4%BB%B6%E9%94%81/</link>
      <pubDate>Sat, 18 May 2019 22:54:58 +0800</pubDate>
      
      <guid>/blog/2019/05/18/golang%E6%96%87%E4%BB%B6%E9%94%81/</guid>
      <description> 多个goroutine同时操作一同一个文件时，很容易出现数据混乱，因此有必要对文件进行加锁
 </description>
    </item>
    
    <item>
      <title>Zsh启动优化</title>
      <link>/blog/2019/05/14/zsh%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 14 May 2019 21:41:40 +0800</pubDate>
      
      <guid>/blog/2019/05/14/zsh%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</guid>
      <description>主要优化方法  偶尔执行一次的sh脚本，不要每次都执行，需要的时候再执行，举例：
# 下面的配置保证每次打开终端的时候，都可以执行python虚拟环境的workon/mkvirtualenv/rmvirtualenv等命令 # source /usr/local/bin/virtualenvwrapper.sh # source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh # 修改为函数的形式，需要执行python虚拟环境命令的时候再执行这个函数 start_virtualenvwrapper() { source /Library/Frameworks/Python.framework/Versions/3.6/bin/virtualenvwrapper.sh }  懒加载。有些命令需要的时候再加载，举例：k8s命令kubectl
# lazy load begin if [ $commands[kubectl] ]; then # Placeholder &#39;kubectl&#39; shell function: # Will only be executed on the first call to &#39;kubectl&#39; kubectl() { # Remove this function, subsequent calls will execute &#39;kubectl&#39; directly unfunction &amp;quot;$0&amp;quot; # Load auto-completion source &amp;lt;(kubectl completion zsh) # Execute &#39;kubectl&#39; binary $0 &amp;quot;$@&amp;quot; } fi # lazy load end  把类似$(brew &amp;ndash;prefix dvm)的命令直接修改为其执行后的路径值，因为这条命令执行比较耗时</description>
    </item>
    
    <item>
      <title>Curl常用操作</title>
      <link>/blog/2019/05/13/curl%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 13 May 2019 11:02:34 +0800</pubDate>
      
      <guid>/blog/2019/05/13/curl%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>curl &amp;ndash;help/&amp;ndash;manual查看完整信息
  使用curl post上传文件，multipart/form-data
 如果不设置filename，默认的filename值就是file的名字，本例的&amp;rdquo;go.sum&amp;rdquo;
 curl -x 127.0.0.1:6060 -F &amp;ldquo;appkey=xxxx&amp;rdquo; -F &amp;ldquo;projectCode=platformtool&amp;rdquo; -F &amp;ldquo;appsecret=xxxx&amp;rdquo; -F &amp;ldquo;file=@go.sum;filename=test&amp;rdquo; http://xxxx.tongdun.me/v1/resource/upload
报文内容： POST /v1/resource/upload HTTP/1.1 Host: xxxx.tongdun.me User-Agent: curl/7.54.0 Accept: */* Content-Length: 15262 Expect: 100-continue Content-Type: multipart/form-data; boundary=------------------------7bba7e03d249b584 Connection: close --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;appkey&amp;quot; xxxx --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;projectCode&amp;quot; platformtool --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;appsecret&amp;quot; xxxx --------------------------7bba7e03d249b584 Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;test&amp;quot; Content-Type: application/octet-stream cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw= github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ= github.com/BurntSushi/toml v0.</description>
    </item>
    
    <item>
      <title>Mac常用操作</title>
      <link>/blog/2019/05/13/mac%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 13 May 2019 10:43:39 +0800</pubDate>
      
      <guid>/blog/2019/05/13/mac%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description> 在Finder中显示/隐藏隐藏文件
defaults write com.apple.Finder AppleShowAllFiles YES/NO
killall Finder
 打开多个实例
open -n /Applications/xxx.app
  3.
   </description>
    </item>
    
    <item>
      <title>个人所得税2019</title>
      <link>/life/2019/05/11/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E2019/</link>
      <pubDate>Sat, 11 May 2019 00:36:45 +0800</pubDate>
      
      <guid>/life/2019/05/11/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E2019/</guid>
      <description>计算方法  个税精灵 个人所得税  关注两个基数  在岗职工的社会保险缴费基数，新的缴费基数通常在每年的7月调整启用,同时对1-6月预收的社会保险费进行差额补退。
 这两个值直接影响五险一金，关乎个人收入，并且很多公司通过采用较低标准减负。
  1. 社保基数，是根据最低标准还是最高标准？还是中间某个值 2. 住房公积金基数，是否是按照工资总额？  五险一金缴纳比例 社保缴费基数“上下限”，根据上一年浙江省在岗职工年平均工资计算，比如：
+ 月平均工资（保留小数点后两位）为61099元÷12月=5091.58元/月 + 保底工资基数（保留小数点后两位）为5091.58×60%=3054.95 + 封顶工资基数（保留小数点后两位）为5091.58×300%=15274.74   目前市本级（含萧山、余杭、富阳）的企业单位职工五险的缴费费率
   - 个人 企业     养老保险 8% 14%   医疗保险 2% 10.5%   失业保险 0.5% 0.5%   工伤保险 0 0.3%   生育保险 0 1.2%    目前市本级（含萧山、余杭、富阳）有雇工的个体工商户职工五险的缴费费率
   - 个人 企业     养老保险 8% 10%   医疗保险 2% 10.</description>
    </item>
    
    <item>
      <title>Markdown语法及常见用法举例</title>
      <link>/blog/2019/05/10/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B/</link>
      <pubDate>Fri, 10 May 2019 21:18:52 +0800</pubDate>
      
      <guid>/blog/2019/05/10/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B/</guid>
      <description>缩进 标题（Headers）
 Markdown 标题支持两种形式：
 1.1 用1~6个#标记
 在标题开头加上1~6个#，依次代表一级标题、二级标题&amp;hellip;.六级标题
 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ###### 六级标题  一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 1.2 用=和-标记
 在标题底下 加上任意个=代表一级标题，-代表二级标题
 一级标题 ====== 二级标题 ----------  一级标题 二级标题 列表（Lists）
 Markdown 支持有序列表和无序列表。列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等
 2.1 无序列表（Unordered Lists）
 无序列表使用-、+和*作为列表标记
 - Red - Green - Blue * Red * Green * Blue + Red + Green + Blue   Red Green Blue</description>
    </item>
    
    <item>
      <title>关于shell的各种括号的用法</title>
      <link>/blog/2019/05/10/%E5%85%B3%E4%BA%8Eshell%E7%9A%84%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 10 May 2019 20:52:10 +0800</pubDate>
      
      <guid>/blog/2019/05/10/%E5%85%B3%E4%BA%8Eshell%E7%9A%84%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>大部分情况可以通用，建议使用双中括号[[]]，不同的shell表现也不尽相同
 正确的用法 1. 逻辑与：[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; -a &amp;quot;3&amp;quot; = &#39;3&#39; ]、[[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; &amp;amp;&amp;amp; &amp;quot;3&amp;quot; = &#39;3&#39; ]]、[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;3&amp;quot; = &#39;3&#39; ] 2. 逻辑或：[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; -o &amp;quot;3&amp;quot; = &#39;3&#39; ]、[[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; || &amp;quot;3&amp;quot; = &#39;3&#39; ]]、[ &amp;quot;2&amp;quot; = &amp;quot;2&amp;quot; ] || [ &amp;quot;3&amp;quot; = &#39;3&#39; ] 3. []可以替换为test :if [ -e zshrctest ];then;echo &amp;quot;yes&amp;quot;;fi 等价于 if test -e zshrctest;then;echo &amp;quot;yes&amp;quot;;fi 3.</description>
    </item>
    
    <item>
      <title>潜意识学习</title>
      <link>/life/2019/05/03/%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/life/2019/05/03/%E6%BD%9C%E6%84%8F%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid>
      <description>愿你在所得少于付出时，不会终日愤愤；愿你在所得超过付出时，不必终日惶恐。
—— 东野圭吾
 这个视频系列可以精读：https://www.youtube.com/channel/UCaKZDEMDdQc8t6GzFj1_TDw</description>
    </item>
    
  </channel>
</rss>