<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SGL&#39;s Blog on 道法自然</title>
    <link>/blog/</link>
    <description>Recent content in SGL&#39;s Blog on 道法自然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>mongo EOF</title>
      <link>/blog/2019/2019-04-27-mongo-eof/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-04-27-mongo-eof/</guid>
      <description>很多事情仅仅的是严肃的提出问题都感觉很难，更何况还得要先发现它。
 Question 描述 项目中使用：github.com/globalsign/mgo这个库，在一次主从切换之后，mongo后续的操作都失败了, 错误信息输出：EOF。
引用网上遇到同样问题的其他描述：
 The problem I have is, when the connection to the mongodb server fails (the server drops the connection sometimes or mongodb server fails), then my pointer to the session variable doesn&#39;t work anymore. Even if the internet connection comes back, mgo driver doesn&#39;t reconnect anymore, instead of this I get the error (when I do Find().One() method call): &amp;quot;EOF&amp;quot;
 解决思路   Call Refresh on the session, which makes it discard (or put back in the pool, if the connection is good) the connection it&amp;rsquo;s holding, and pick a new one when necessary.</description>
    </item>
    
    <item>
      <title>Kafka中消息分配策略</title>
      <link>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>非淡泊无以明，非宁静无以致远
 Question 关于kafka中partation和consumer的是如何执行分配的。今早骑自行车的时候突然想起这个问题。它是怎么分配的，我记得我看到好几次相关的介绍文章，现在却想不起来？
sense 很多时候，我们在看完一篇技术文档时，感觉对其中的内容都了解了，其实不然。这也是所谓的被动输入和主动输出的区别所在。相比主动输出而言，被动输入缺少了深层思考的态度。得到一些老师的课里就谈到过主动输出的重要性。
很多概念都已经记不起来了，文章的内容可能也不够准确，但重在思考和想法的过程：
Thinking partaion是数据的存储单位，一个topic至少存在一个partation。consumer使用主动拉数据的方式来消费消息，这就是所有已知概念。那么partation和consumer是如何分配的呢？这里我们假设消息数据总量是一样的。
首先，应该存在一个类似LVS的负载均衡器，因为当consumer增加或者减少时，对应的分配策略也需要做相应的调整。在consumer注册成为消费者时，提交的信息中有consumer Group的概念，这非常好理解，即同一个组的consumer会独立处理一份数据。同时，因为有了Group，我们在管理的时候就会简单很多。当然，所有的讨论都是以一个Group为前提的。
1:1 从最简单的开始考虑，假设现在partation和consumer的数量比例是1:1，那就没有那么多事了，简单明了。
1:2 假设是1:2呢？问题来了，好比现在只有一个数据，但有AB两个线程都要读它，且A和B中有且只有一个能读到。这种情况在计算机中相当普遍，通用的处理方式就是加锁，以保证数据只被其中一个线程处理。但加锁就意味着性能开销，尤其是高并发的场景。
继续按照这个思路来考虑，两个consumer同时向一个partation发起请求，需要一个全局锁来控制每个消息只能返回给请求中的一个。相比较1:1的方式，这样的性能肯定是提高了不少。
2:1 假设是2:1呢？这个也很直观，两份数据，但只有一个消费者，那肯定都需要这一个消费者来处理了，就跟CPU任务调度还有些类似。
如果跟1:2的分配策略比较呢？这里通过将原来的一份数据平均分成两份，去掉了1:2中加锁的开销，但只有一个connsumer来消费数据。好比是单核CPU任意处理数据跟双核CPU加锁处理数据。
2:2 假设是2:2呢，我们可以平均分配partation和consumer，而且这样系统性能却得到最大提升，不仅去掉了锁的开销，还有两个线程来同时消费。
结论 通过上面的对比，我们可以清楚的发现，通过调整partation和consumer的数量就可以将系统性能达到最大，完全不需要引入锁机制。这样想的话，分配就很简单了。</description>
    </item>
    
    <item>
      <title>How to use godog</title>
      <link>/blog/2018/12-29-how-to-use-godog/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12-29-how-to-use-godog/</guid>
      <description>首先访问Git的地址：Godog，它也是用来做Go Test一样的事情，只是换了一种形式。引入了一个概念：BDD。通俗的讲，就是虚拟现实场景，完成一个业务的测试。
Godog了解 首先介绍Godog是用来干什么的，我也是根据版本库提供的README来解释的，建议大家自己去看看。首先，我们要定义一个场景：feature。这里我们创建一个文件夹feature，专门用来存储这类文件。然后创建一个文件：godogs.feature。文件内容如下：
# file: $GOPATH/src/godogs/features/godogs.feature Feature: 购买红酒 这里是一堆对这个Feature的描述 描述的继续... Scenario: 买一瓶红酒 Given Neojos Has 5 coins When I buy Red wine Then should be 1 remaining  在控制台执行godog时，控制台会输出默认建议的代码。输出如下：
You can implement step definitions for undefined steps with these snippets: func neojosHasCoins(arg1 int) error { return godog.ErrPending } func iBuyRedWine() error { return godog.ErrPending } func shouldBeRemaining(arg1 int) error { return godog.ErrPending } func FeatureContext(s *godog.Suite) { s.Step(`^Neojos Has (\d+) coins$`, neojosHasCoins) s.</description>
    </item>
    
    <item>
      <title>Net Transport</title>
      <link>/blog/2018/12-08-net-transport/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12-08-net-transport/</guid>
      <description>版本 0.02
在调用第三方请求时，正确使用Client也不是一件非常容易的事。
下面是截取的一段描述，建议Client或Transport在整个服务期间最好是全局单例的，Transport本身会维护连接的状态，而且线程安全。强烈建议，不要使用系统提供的任何默认值。
 The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
 Transport 如下是官方的简要描述。Transport字段在Client中被声明为接口类型，而实现这个接口的是Transport类型（略显绕）。在net包内部也提供了默认的实现变量：DefaultTransport。
// Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper  看一下RoundTripper这个接口，官方描述：
 RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</description>
    </item>
    
    <item>
      <title>Deafult Decimal</title>
      <link>/blog/2018/12-01-deafult-decimal/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/12-01-deafult-decimal/</guid>
      <description>版本 0.00
 我说：version dependent 表示我们的思考时，应该依赖具体的版本。举个例子，你把2015年看到的一些redis机制拿到现在跟别人谈论，很容易闹出笑话。在3年的时间里，它可能已经做了无数的优化。所以，思考要与时俱进。
 引言 在涉及到支付业务的时候，数据库里的钱怎么存：  存储单位是元。在业务处理的时候就会涉及到浮点数，很多商家喜欢将价钱定义为0.99而不是1元。这在使用过程中非常忌讳是否相等的比较。浮点数的比较经常喜欢用|floatA - floatB| &amp;gt; 0.00001来，很多第三方库也提供了比较方法。 存储单位时分。为了避免浮点类型比较时的不确定性，决定使用整形来替代。一般来说没有问题，可如果是要严格缺心眼打折，比如给一个售价4.99的打5折，那么最后就会存在5里的情况。一般都喜欢向上取整，应收用户2.495，实收用户2.50.  那么在MySQL的Column中该如何存储呢？  如果是分的话，肯定时当整形来存储的。但如果时浮点的，大家都会选择decimal，因为该类型不会丢失精度。 存储为字符串。浮点数保留指定位数的字符串。在Go中我也尝试过，fmt.Sprintf(&amp;quot;%.2f&amp;quot;, 3.091)还是靠谱的。  这篇文章当然不是来分析这两种存储方式的，也不是来分析该存储什么数据类型的。而仅仅时想阐述一个之前不了解的知识点（知识点太少，写点别的来凑）。
deault value 在MySQL建表的过程中，一般都会指定DEFAULT VALUE。在执行INSERT时，如果不指定该字段，MySQL会默认使用该默认值来替代。下面是创建的一个decimal类型字段，在Go中使用xorm 来表示，可以看出，xorm使用字符串类型来接收decimal类型的值。
type table_test struct { PayPrice string `xorm:&amp;quot;not null default 0.00 comment(&#39;支付价钱&#39;) DECIMAL(10,2)&amp;quot;` }  最后发现：在测试环境下，向数据库插入记录时，不指定PayPrice没有任何问题。但到了正式服数据表插入便失败了。报错信息如下：
{ &amp;quot;Number&amp;quot;: 1366, &amp;quot;Message&amp;quot;: &amp;quot;Incorrect decimal value: &#39;&#39; for column &#39;pay_price&#39; at row 1&amp;quot; }  STRICT_TRANS_TABLES 查询sql_mode如下：
show variables like &#39;sql_mode&#39;  下面的内容截取至:Strict SQL Mode:</description>
    </item>
    
  </channel>
</rss>