<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>数据一致性（一） - 道法自然</title>
    <meta property="og:title" content="数据一致性（一） - 道法自然">
    

    
      
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.14.1/styles/googlecode.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/custom.css" />
    <link rel="stylesheet" href="/css/custom.css" />

  </head>

  
  <body class="blog">
    <header class="masthead">
      <h1 class="headimg">
    
    <a href="/"><img src="/img/headimg.png" alt="Fuhui "></a>
</h1>



      <nav class="menu">
        <input id="menu-check" type="checkbox" />
        <label id="menu-label" for="menu-check" class="unselectable">
          <span class="icon close-icon">✕</span>
          <span class="icon open-icon">☰</span>
          <span class="text">Menu</span>
        </label>
        <ul>
        
        
        <li><a href="/blog/">Blog</a></li>
        
        <li><a href="/life/">Life</a></li>
        
        <li><a href="/categories/">Categories</a></li>
        
        <li><a href="/tags/">Tags</a></li>
        
        <li><a href="/about/">About</a></li>
        
        


        </ul>
      </nav>
    </header>

    <article class="main">
      <header class="title">
      <h1>数据一致性（一）</h1>




    
    
    <section class="post-meta">
        <span class="post-author">付辉
        
            
            
             /  2018-10-20
            
        </span>
        
        <a href="/tags/transaction">transaction</a>
        
    </section>
    



<hr>
      </header>




<p><em><u>版本：0.00</u></em></p>

<p><code>MySQL</code>的事务是数据一致性的典范，事务内的执行要么都成功，要么都失败。但业务系统涉及系统间的相互调用，涉及的数据库也不尽相同，所以实现数据一致性还是有挑战的。</p>

<p>首先了解强一致性和弱一致性。在微服务中，系统间通过<code>HTTP</code>的方式相互调用，很难实现数据的强一致。我们这里主要说弱一致性，也就是数据最终一致性。</p>

<p>数据一致性还有个重要的前提：支持幂等。也就是说，只要请求参数不变，那么无论重复请求多少次，结果都一样。在对接第三方支付时，这个词出现的频率还是老高的。</p>

<h2 id="购买业务">购买业务</h2>

<p>蜗牛要在一家电商网站买电子书，整个购买流程和涉及的系统<strong>虚构</strong>如下图。过程涉及检查它是否已经买过，然后是生成订单号、支付、交付（实际上订单系统不包含支付功能，这里简化处理）。</p>

<p><center></p>

<p><img src="https://i.loli.net/2018/12/02/5c02b2ed6bbeb.png" alt="image" /></p>

<p></center></p>

<p>交付涉及三个系统，在任何一个系统内，数据库的事务都只能保证它服务内的数据一致。而且，如果在事务过程中引入了调用第三方的<code>HTTP</code>请求，数据库的事务执行结果甚至有可能会被污染。比如，<code>HTTP</code>请求超时返回失败，但实际上请求却执行成功的场景。</p>

<h2 id="代码设计">代码设计</h2>

<p>参考之前写的 <a href="http://neojos.com/blog/2018/04-24-saga-pattern/">Saga Pattern</a>模式，对任何一个外部服务的调用都引入两个行为：<strong>执行</strong>和<strong>补偿</strong>。补偿是对执行结果的修正。比如对于用户支付失败的场景，补偿行为可以是接口重试、可以是直接退款、还可以推送<code>MQ</code>异步修复等。</p>

<p>统一使用<code>interface</code>来定义一套规范。每一种支付方式以及购买产品所调用的外部服务可能不尽相同，用<code>interface</code>来达到统一调用的目的。补偿的行为都基于执行动作返回的错误，所以我们需要实现自己的错误码。</p>

<pre><code class="language-go">type DeliverPattern interface {
	//是否需要执行交付流程
	Check(ctx *context.Context) (bool, error)

	//支付及支付补偿
	DoPay(ctx *context.Context) error
	PayCompensate(ctx *context.Context, doErr error) error

	//交付及对应的补偿
	DoDeliver(ctx *context.Context)
	DeliverCompensate(ctx *context.Context, doErr error) error
}
</code></pre>

<h2 id="如何补偿">如何补偿</h2>

<p>对于如何补偿，不同的业务有不同的补偿方式，当让不能一概而论。但整体的思想，我觉得还是不外乎两种。当然，下面的两种描述是自己这样称呼的。</p>

<h4 id="事务类"><code>事务类</code></h4>

<p>首先便是数据库<code>事务</code>类，任何一个流程失败，整个事务内的操作全部反向回滚。沿着这样的思路，接口定义中<code>PayCompensate</code>应该实现<code>DoPay</code>的回滚操作，而<code>DeliverCompensate</code>应该实现<code>DoPay</code>以及<code>DoDeliver</code>的回滚操作。</p>

<p>我们需要在操作的同时维护一个回滚操作的队列，任何一个<code>Do</code>行为的完成，都需要在回滚队列中插入对应的回滚方法。当后面任何一个<code>Do</code>操作失败，统一执行回滚队列的方法。</p>

<p>这样的困境在于你不能完全保证回滚方法一定成功执行。而且出于性能考虑，还需要结合异步队列，通过后台重试来保证整个业务流程彻底回滚成功或回滚失败。</p>

<h4 id="状态类"><code>状态类</code></h4>

<p>每个业务都会拆分成各个更小的块，就跟写代码空行一样，这里的<code>DeliverPattern</code>也是根据业务流程拆分成更小的执行粒度。我们可以为每个<code>Do</code>行为都设置一个状态码，类似于状态机，记录每一次购买的各个状态。</p>

<pre><code class="language-go">const (
	StatusDoPaySuccess           = 1
	StatusDoPayCompensateSuccess = 2
	StatusDoPayCompensateFailure = 3
)
</code></pre>

<p>这样我们补偿方法中执行的不再是回滚操作，而是<code>Do</code>方法的重试。如果补偿成功，继续执行后续的操作，如果补偿失败，记录下该状态，后续看看怎么补偿。</p>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/blog/2018/10-12-go-interface-%E7%B1%BB%E5%9E%8B/">Go Interface 类型</a></span>
  <span class="nav-next"><a href="/blog/2018/11-03-singleton-pattern/">singleton pattern</a> &rarr;</span>
</nav>





<script src="//yihui.name/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  



<script src="//cdn.bootcss.com/highlight.js/9.14.1/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.14.1/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.14.1/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.14.1/languages/tex.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.14.1/languages/go.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">&copy; 2019 | <a href="https://github.com/shengulong">Github</a> | <a href="https://www.cnblogs.com/shengulong/">cnblogs</a> | <a href="https://shengulong.github.io/">Github Pages</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

